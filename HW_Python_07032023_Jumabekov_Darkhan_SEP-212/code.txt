'''
5*) Создайте кортеж из 7-ми именованных кортежей учащихся ВУЗов.
В именованном кортеже будут присутствовать следующие поля:
имя студента, возраст, оценка за семестр, город проживания.
Функция good_students() будет принимать этот кортеж,
вычислять среднюю оценку по всем учащимся и выводить на печать следующее сообщение:
"Ученики {список имен студентов через запятую} в этом семестре хорошо учатся!".
В список студентов, которые выводятся по результатам работы функции,
попадут лишь те, у которых оценка за семестр равна или выше средней по всем учащимся.
'''

from collections import namedtuple, Counter
from functools import reduce

Student = namedtuple(
    'Student', ['name', 'age', 'rating', 'city']
)

vasya = Student('Вася', 20, 4.6, 'Astana')
petya = Student('Петя', 18, 3.2, 'Karaganda')
dima = Student('Дима', 19, 4.1, 'Aktobe')
ivan = Student('Иван', 17, 4.8, 'Shymkent')
arman = Student('Арман', 20, 4.4, 'Almaty')
omar = Student('Омар', 18, 4.0, 'Taraz')
abay = Student('Абай', 19, 4.6, 'Aktau')

students_tuple = (vasya, petya, dima, ivan, arman, omar, abay)

avg_best_rating = 4.5

def good_students(students_tuple):
    print('Ученики', end=' ')
    for student in students_tuple:
        if student.rating >= avg_best_rating:
            print(student.name, end=', ')
    print('в этом семестре хорошо учатся!')

'''
4) Напишите функцию superset(), которая принимает 2 множества.
Результат работы функции - вывод в консоль одного из сообщений в зависимости от ситуации:
1 - "Супермножество не обнаружено"
2 – "Объект {X} является чистым супермножеством"
3 – "Множества равны"
'''

s1 = set([1,2,3,4,5])
s2 = set([1,2,3,4,5])

def superset(s1, s2):
    print(type(s1))
    if not isinstance(s1, set) and not isinstance(s2, set):
        print('Супермножество не обнаружено')
    if isinstance(s1, set):
        print(f'Объект {str(s1)} является чистым супермножеством')
    if isinstance(s2, set):
        print(f'Объект {str(s2)} является чистым супермножеством')
    if s1 == s2:
        print('Множества равны')

'''
5*) Имеется ряд словарей с пересекающимися ключами (значения - положительные числа).
Напишите 2 функции, которые делают с массивом словарей следующие операции:
1-ая функция max_dct(*dicts) формирует новый словарь по правилу:
 - Если в исходных словарях есть повторяющиеся ключи, выбираем среди их значений максимальное и присваиваем этому ключу (например, в словаре_1 есть ключ "а" со значением 5, и в словаре_2 есть ключ "а", но со значением 9. Выбираем максимальное значение, т. е. 9, и присваиваем ключу "а" в уже новом словаре).
 - Если ключ не повторяется, то он просто переносится со своим значением в новый словарь 
 (например, ключ "с" встретился только у одного словаря, а у других его нет. Следовательно, переносим в новый словарь этот ключ вместе с его значением). Сформированный словарь возвращаем.
2-ая функция sum_dct(*dicts) суммирует значения повторяющихся ключей.
Значения остальных ключей остаются исходными. (Проводятся операции по аналогу первой функции, но берутся не максимумы, а суммы значений одноименных ключей).
Функция возвращает сформированный словарь.
'''

dic1 = {'a': 1, 'b': 2, 'c': 3}
dic2 = {'d': 3, 'e': 4, 'a': 5}
dic3 = {'b': 1, 'c': 4, 'd': 5}

def max_dct(*dicts):
    new_dic = {}
    for dic in dicts:
        for key in dic:
            if new_dic.__contains__(key):
                if new_dic[key] < dic[key]:
                    new_dic[key] = dic[key]
            else:
                new_dic[key] = dic[key]
    return new_dic

def sum_dct(*dicts):
    new_dic = {}
    for dic in dicts:
        for key in dic:
            if new_dic.__contains__(key):
                new_dic[key] += dic[key]
            else:
                new_dic[key] = dic[key]
    return new_dic

if __name__ == '__main__':
    # Task 1
    # good_students(students_tuple)

    #Task 2
    # superset(s1, s2)

    #Task 3
    print(max_dct(dic1, dic2, dic3))
    print(sum_dct(dic1, dic2, dic3))

